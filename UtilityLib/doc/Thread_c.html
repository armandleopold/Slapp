<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />
<link rel="stylesheet" href="./robodoc.css" type="text/css" />
<title>./Thread.c</title>
<!-- Source: ./Thread.c -->
<!-- Generated with ROBODoc Version 4.99.34 (Jan  4 2008) -->
</head>
<body>
<div id="logo">
<a name="robo_top_of_doc">Utility Library</a>
</div> <!-- logo -->
<div id="navigation">
<a class="menuitem" href="./toc_index.html#top">Table of Contents</a>
<a class="menuitem" href="./robo_sourcefiles.html#top">Sourcefiles</a>
<a class="menuitem" href="./masterindex.html#top">Index</a>
<a class="menuitem" href="./robo_functions.html#top">Functions</a>
<a class="menuitem" href="./robo_modules.html#top">Modules</a>
<a class="menuitem" href="./robo_types.html#top">Types</a>
<a class="menuitem" href="./robo_variables.html#top">Variables</a>
</div> <!-- navigation -->
<div id="content">
<hr />
<a name="SWL2fThread">
</a><a name="robo10"></a><h2>SWL/Thread [ Modules ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="./robo_modules.html#robo_top_of_doc">Modules</a> ]</p>
<p class="item_name">INTRODUCTION</p>
<pre>      Simple module to create thread and usual synchronization objects (Mutex &amp;
      semaphore).

      As usual, no safeguards are provided. Threads are as easy to start as it is
      to shoot yourself in your foot with them.
</pre>

<hr />
<a name="Thread2fMutexCreate">
</a><a name="robo90"></a><h2>Thread/MutexCreate [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>MutexCreate</strong> - critical section safe guard
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      Mutex <strong>MutexCreate</strong>(void);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      Create a synchronization object that will allow you to run atomic code.
      Like usual beware of deadlock, eitheir by forgetting to release the mutex,
      or by locking a set of mutexes in different order in different threads.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo92">MutexEnter</a>, <a href="#robo92">MutexLeave</a>, <a href="#robo92">MutexTryEnter</a>, <a href="#robo91">MutexDestroy</a>
</pre>

<hr />
<a name="Thread2fMutexDestroy">
</a><a name="robo91"></a><h2>Thread/MutexDestroy [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>MutexDestroy</strong> - release memory held by lock
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      void <strong>MutexDestroy</strong>(Mutex lock);
</pre>

<hr />
<a name="Thread2fMutexEnter">
</a><a name="robo92"></a><h2>Thread/MutexEnter, Thread/MutexLeave,<br />Thread/MutexTryEnter [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>MutexEnter</strong>    - Ask for access to the lock. Blocking.
      <strong>MutexLeave</strong>    - Permit other thread to have access to the lock.
      <strong>MutexTryEnter</strong> - Ask for access to the lock. Non-blocking.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      void <strong>MutexEnter</strong>(Mutex lock);
      void <strong>MutexLeave</strong>(Mutex lock);
      Bool <strong>MutexTryEnter</strong>(Mutex lock);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      <strong>MutexEnter</strong> will wait until the calling thread can access the lock. Once you
      gain access, all other threads will block by calling <strong>MutexEnter</strong> on the mutex,
      and until you call <strong>MutexLeave</strong>.

      You can safely call multiple times <strong>MutexEnter</strong> on the same mutex, within the
      same thread, but you must have the same number of <strong>MutexLeave</strong> call to release
      the lock held on the mutex by your <a href="#robo10">Thread</a>.

      <strong>MutexTryEnter</strong> will ask for access to the lock. If it can obtain it
      immediately, the mutex will be locked by your thread and the function will
      return True. Otherwise mutex ownership won't be changed and False will be
      returned.

      If mutiple threads are waiting on locking a given mutex, there is no
      guarantee on which one will get access. It might very well cause the well
      known effect of starvation for one of them.

      Functions are NULL-safe.
</pre>
<p class="item_name">RESULT</p>
<pre>      <strong>MutexTryEnter</strong> will return True if lock has been acquired on the mutex. False
      otherwise.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo90">MutexCreate</a>
</pre>

<hr />
<a name="Thread2fSemAdd">
</a><a name="robo93"></a><h2>Thread/SemAdd [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>SemAdd</strong> - Add amount to currrent value in semaphore.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      void <strong>SemAdd</strong>(Semaphore s, int count);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      Increase the value of the semaphore to the specified amount, releasing
      potential thread waiting for it.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo96">SemWait</a>
</pre>

<hr />
<a name="Thread2fSemClose">
</a><a name="robo94"></a><h2>Thread/SemClose [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>SemClose</strong> - release memory held by semaphore.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      void <strong>SemClose</strong>(Semaphore s);
</pre>

<hr />
<a name="Thread2fSemInit">
</a><a name="robo95"></a><h2>Thread/SemInit [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>SemInit</strong> - Create a semaphore object.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      Semaphore <strong>SemInit</strong>(int count);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      Create a semaphore with the specified amount as starting value. Semaphore
      are a bit more generic than Mutex, though the former can be emulated using
      an integer and two mutexes.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo96">SemWait</a>, <a href="#robo93">SemAdd</a>
</pre>

<hr />
<a name="Thread2fSemWait">
</a><a name="robo96"></a><h2>Thread/SemWait [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>SemWait</strong> - Remove one unit in the semaphore or wait until one arrives if count is 0.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      Bool <strong>SemWait</strong>(Semaphore s);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      This will decrease the count of the integer contained in the semaphore. If
      the current count is 0, it will wait infinately until it reach one. If
      multiple threads are waiting for a unit to be released, there will be no
      guarantee on which thread will be awaken.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo93">SemAdd</a>
</pre>

<hr />
<a name="Thread2fThreadCreate">
</a><a name="robo97"></a><h2>Thread/ThreadCreate [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>ThreadCreate</strong> - start an asynchronous program flow.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      <a href="#robo10">Thread</a> <strong>ThreadCreate</strong>(ThreadCb func, APTR arg);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      Starts a new execution flow, independant of the caller thread.

      Be sure to link your program with a thread safe standard C library, or at
      least avoiding non-thread safe functions in your thread (which might go as
      far as not using malloc if linked to the wrong library).
</pre>
<p class="item_name">RESULT</p>
<pre>      An opaque ID with which you cannot do much, except checking if thread
      creation has succeeded or not. You cannot cancel thread execution, nor send
      a signal to it. You cannot know whan thread exited, you have to use
      synchronization objects.
</pre>
<p class="item_name">SEE ALSO</p>
<pre>      <a href="#robo90">MutexCreate</a>, <a href="#robo95">SemInit</a>
</pre>

<hr />
<a name="Thread2fThreadPause">
</a><a name="robo98"></a><h2>Thread/ThreadPause [ Functions ]</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="#robo10">Thread</a> ] [ <a href="./robo_functions.html#robo_top_of_doc">Functions</a> ]</p>
<p class="item_name">NAME</p>
<pre>      <strong>ThreadPause</strong> - Pause current thread.
</pre>
<p class="item_name">SYNOPSIS</p>
<pre>      void <strong>ThreadPause</strong>(int delay);
</pre>
<p class="item_name">FUNCTION</p>
<pre>      Pause the current thread of the specified amount of miliseconds. This
      delay is uninterruptible.
</pre>

</div> <!-- content -->
<div id="footer">
<p>Generated from ./Thread.c with <a href="http://www.xs4all.nl/~rfsber/Robo/robodoc.html">ROBODoc</a> V4.99.34 on Thu Mar 06 2008 10:21:26
</p>
</div> <!-- footer -->
</body>
</html>
